# 开发规范

## 3. 开发规范

### 3.1 命名规范

#### 3.1.1 包命名
- **模块包**: `vip.geekclub.{模块名}`
- **功能包**: 使用功能描述，如 `command`、`query`、`domain`
- **子包**: 使用具体业务，如 `department`、`menu`

#### 3.1.2 类命名
- **聚合根**: 使用业务实体名称，如 `Department`、`Menu`
- **命令**: 使用 `{操作}{实体}Command` 格式，如 `CreateDepartmentCommand`
- **命令处理器**: 使用 `{操作}{实体}CommandHandler` 格式
- **查询服务**: 使用 `{实体}{功能}QueryService` 格式
- **值对象**: 使用业务概念名称，如 `ContactInfo`、`SortOrder`

#### 3.1.3 方法命名
- **业务方法**: 使用动词+名词格式，如 `createDepartment`、`updateInfo`
- **查询方法**: 使用 `get`、`find`、`query` 前缀
- **验证方法**: 使用 `validate` 前缀

### 3.2 代码组织规范

#### 3.2.1 聚合根编写规范
```java
@Entity
@Table(name = "table_name")
@Getter
@Setter(AccessLevel.PRIVATE)  // 私有setter，防止外部直接修改
@NoArgsConstructor(access = AccessLevel.PROTECTED)  // 保护的无参构造
public class EntityName implements AggregateRoot<Long> {
    
    // ================================ 字段定义 ================================
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Embedded
    private AuditInfo auditInfo = new AuditInfo();
    
    @Version
    private Long version;
    
    // 业务字段
    private String name;
    
    // ================================ 业务方法 ================================
    
    /**
     * 创建实体的静态工厂方法
     */
    public static EntityName create(String name, ...) {
        // 参数验证
        AssertUtil.notBlank(name, "名称不能为空");
        
        // 创建实例
        EntityName entity = new EntityName();
        entity.setName(name);
        
        return entity;
    }
    
    /**
     * 业务操作方法
     */
    public void updateInfo(String name, ...) {
        // 业务验证
        validateUpdateInfo(name);
        
        // 更新字段
        this.name = name;
    }
    
    // ================================ 私有方法 ================================
    
    private void validateUpdateInfo(String name) {
        // 业务验证逻辑
    }
}
```

#### 3.2.2 值对象编写规范
```java
@Embeddable
public class ValueObjectName {
    
    // 字段定义
    private String value;
    
    // 构造函数（包含验证）
    public ValueObjectName(String value) {
        validateValue(value);
        this.value = value;
    }
    
    // 业务方法
    public boolean isValid() {
        return value != null && !value.trim().isEmpty();
    }
    
    // 私有验证方法
    private void validateValue(String value) {
        AssertUtil.notBlank(value, "值不能为空");
        // 其他业务验证
    }
    
    // 重写equals和hashCode
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        ValueObjectName that = (ValueObjectName) obj;
        return Objects.equals(value, that.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
}
```

#### 3.2.3 命令编写规范
```java
public class CreateEntityCommand implements Command {
    
    @NotBlank(message = "名称不能为空")
    @Size(max = 50, message = "名称不能超过50个字符")
    private String name;
    
    @NotNull(message = "父级ID不能为空")
    private Long parentId;
    
    @Min(value = 1, message = "排序号必须大于0")
    @Max(value = 999, message = "排序号不能超过999")
    private final Integer sortOrder;
    
    // 构造函数
    public CreateEntityCommand(String name, Long parentId, Integer sortOrder) {
        this.name = name;
        this.parentId = parentId;
        this.sortOrder = sortOrder;
    }
    
    // getters
    public String getName() { return name; }
    public Long getParentId() { return parentId; }
    public Integer getSortOrder() { return sortOrder; }
}
```

#### 3.2.4 命令处理器编写规范
```java
@AllArgsConstructor
@Service
public class CreateEntityCommandHandler implements CommandHandler<CreateEntityCommand, Long> {
    
    private final EntityRepository entityRepository;
    private final EntityDomainService entityDomainService;
    
    @Override
    @Transactional
    public CommandResult<Long> handle(@Validated CreateEntityCommand command) {
        // 1. 业务验证
        entityDomainService.validateEntityNameUnique(command.getName(), command.getParentId());
        
        // 2. 获取父级实体
        Entity parentEntity = entityRepository.findById(command.getParentId())
                .orElseThrow(() -> new ValidationException("指定的父级实体不存在"));
        
        // 3. 创建实体
        Entity entity = Entity.createSubEntity(
                command.getName(),
                parentEntity,
                command.getSortOrder()
        );
        
        // 4. 保存实体
        entityRepository.save(entity);
        
        // 5. 返回结果
        return CommandResult.ok("实体创建成功", entity.getId());
    }
}
```

### 3.3 数据验证规范

#### 3.3.1 命令验证
- 使用 JSR-303 Bean Validation 注解
- 在命令类上添加验证注解
- 在命令处理器方法参数上添加 `@Validated` 注解

```java
public class CreateDepartmentCommand implements Command {
    @NotBlank(message = "部门名称不能为空")
    @Size(max = 50, message = "部门名称不能超过50个字符")
    private String name;
    
    @NotNull(message = "父部门ID不能为空")
    private Long parentId;
}
```

#### 3.3.2 值对象验证
- 在值对象构造函数中进行验证
- 使用 `AssertUtil` 工具类进行断言
- 抛出 `ValidationException` 异常

```java
public class ContactInfo {
    public ContactInfo(String phone, String email) {
        validatePhone(phone);
        validateEmail(email);
        this.phone = phone;
        this.email = email;
    }
    
    private void validatePhone(String phone) {
        AssertUtil.notBlank(phone, "手机号不能为空");
        if (!phone.matches("^1[3-9]\\d{9}$")) {
            throw new ValidationException("手机号格式不正确");
        }
    }
}
```

### 3.4 异常处理规范

#### 3.4.1 异常类型
- **ValidationException**: 数据验证失败
- **BusinessException**: 业务逻辑异常
- **NotFoundException**: 资源不存在
- **ForbiddenException**: 权限不足

#### 3.4.2 异常使用
```java
// 验证异常
throw new ValidationException("部门名称不能为空");

// 业务异常
throw new BusinessException("部门层级不能超过5级");

// 资源不存在
throw new NotFoundException("指定的部门不存在");

// 权限异常
throw new ForbiddenException("没有权限删除该部门");
```

### 3.5 事务管理规范

#### 3.5.1 事务注解使用
- 在命令处理器方法上使用 `@Transactional`
- 在领域服务方法上使用 `@Transactional`（如需要）
- 查询方法通常不需要事务

```java
@Override
@Transactional
public CommandResult<Long> handle(CreateDepartmentCommand command) {
    // 业务逻辑
}
```

#### 3.5.2 事务传播行为
- 默认使用 `REQUIRED` 传播行为
- 对于只读操作，使用 `@Transactional(readOnly = true)`

### 3.6 日志规范

#### 3.6.1 日志级别使用
- **ERROR**: 系统错误，需要立即处理
- **WARN**: 警告信息，可能存在问题
- **INFO**: 重要业务操作信息
- **DEBUG**: 调试信息，开发时使用
- **TRACE**: 详细的执行轨迹

#### 3.6.2 日志内容规范
```java
// 业务操作日志
logger.info("创建部门成功，部门名称：{}，部门ID：{}", departmentName, departmentId);

// 异常日志
logger.error("创建部门失败，部门名称：{}，错误信息：{}", departmentName, e.getMessage(), e);

// 调试日志
logger.debug("开始验证部门名称唯一性，部门名称：{}，父部门ID：{}", departmentName, parentId);
```

### 3.7 注释规范

#### 3.7.1 类注释
```java
/**
 * 部门聚合根
 * 负责管理部门的创建、更新和验证逻辑
 *
 * @author leo
 * @since 1.0
 */
public class Department implements AggregateRoot<Long> {
    // 实现代码
}
```

#### 3.7.2 方法注释
```java
/**
 * 创建子部门
 * 
 * @param name 部门名称
 * @param parent 父部门
 * @param sortOrder 排序号
 * @param contactInfo 联系信息
 * @param description 描述
 * @return 创建的子部门
 * @throws ValidationException 当参数验证失败时
 */
public static Department createSubDepartment(String name, Department parent, 
                                           SortOrder sortOrder, ContactInfo contactInfo, 
                                           String description) {
    // 实现代码
}
```

### 3.8 测试规范

#### 3.8.1 单元测试
- 每个聚合根都要有对应的单元测试
- 测试覆盖所有业务方法
- 测试异常情况

```java
@Test
void shouldCreateDepartmentSuccessfully() {
    // Given
    String name = "技术部";
    Department parent = createParentDepartment();
    
    // When
    Department department = Department.createSubDepartment(name, parent, SortOrder.of(1));
    
    // Then
    assertThat(department.getName()).isEqualTo(name);
    assertThat(department.getParentId()).isEqualTo(parent.getId());
}

@Test
void shouldThrowExceptionWhenNameIsEmpty() {
    // Given
    String name = "";
    Department parent = createParentDepartment();
    
    // When & Then
    assertThatThrownBy(() -> 
        Department.createSubDepartment(name, parent, SortOrder.of(1))
    ).isInstanceOf(ValidationException.class)
     .hasMessage("部门名称不能为空");
}
```

#### 3.8.2 集成测试
- 测试命令处理器的完整流程
- 测试数据库操作
- 测试事务回滚

```java
@SpringBootTest
@Transactional
class CreateDepartmentCommandHandlerTest {
    
    @Autowired
    private CommandBus commandBus;
    
    @Test
    void shouldCreateDepartmentSuccessfully() {
        // Given
        CreateDepartmentCommand command = new CreateDepartmentCommand("技术部", 1L, 1);
        
        // When
        CommandResult<Long> result = commandBus.dispatch(command);
        
        // Then
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getData()).isNotNull();
    }
}
```

### 3.9 性能规范

#### 3.9.1 数据库查询优化
- 使用 JOOQ 进行复杂查询
- 避免 N+1 查询问题
- 合理使用索引

```java
// 好的做法：使用JOIN查询
public List<DepartmentInfo> getDepartmentList() {
    return dslContext
        .select(DEPARTMENT.asterisk(), PARENT.NAME.as("parentName"))
        .from(DEPARTMENT)
        .leftJoin(PARENT).on(DEPARTMENT.PARENT_ID.eq(PARENT.ID))
        .fetchInto(DepartmentInfo.class);
}

// 避免的做法：N+1查询
public List<DepartmentInfo> getDepartmentList() {
    List<Department> departments = departmentRepository.findAll();
    return departments.stream()
        .map(dept -> {
            Department parent = departmentRepository.findById(dept.getParentId()).orElse(null);
            return new DepartmentInfo(dept, parent);
        })
        .collect(Collectors.toList());
}
```

#### 3.9.2 缓存使用
- 对于频繁查询的数据使用缓存
- 合理设置缓存过期时间
- 注意缓存一致性

```java
@Service
public class DepartmentQueryService {
    
    @Cacheable(value = "departments", key = "#id")
    public DepartmentInfo getDepartmentById(Long id) {
        return departmentRepository.findById(id)
            .map(this::convertToInfo)
            .orElse(null);
    }
    
    @CacheEvict(value = "departments", key = "#department.id")
    public void updateDepartment(Department department) {
        departmentRepository.save(department);
    }
}
```

### 3.10 安全规范

#### 3.10.1 输入验证
- 所有用户输入都要进行验证
- 使用白名单验证而不是黑名单
- 防止SQL注入和XSS攻击

```java
// 好的做法：使用验证注解
public class CreateDepartmentCommand implements Command {
    @NotBlank(message = "部门名称不能为空")
    @Pattern(regexp = "^[\\u4e00-\\u9fa5a-zA-Z0-9\\s]{1,50}$", 
             message = "部门名称只能包含中文、英文、数字和空格，长度1-50")
    private String name;
}

// 避免的做法：直接使用用户输入
public void createDepartment(String name) {
    // 没有验证直接使用
    department.setName(name);
}
```

#### 3.10.2 权限控制
- 在命令处理器中进行权限验证
- 使用注解进行方法级权限控制
- 记录敏感操作的审计日志

```java
@Service
public class DeleteDepartmentCommandHandler implements CommandHandler<DeleteDepartmentCommand, Void> {
    
    @Override
    @Transactional
    @PreAuthorize("hasRole('ADMIN')")
    public CommandResult<Void> handle(DeleteDepartmentCommand command) {
        // 权限验证
        if (!hasPermissionToDelete(command.getDepartmentId())) {
            throw new ForbiddenException("没有权限删除该部门");
        }
        
        // 业务逻辑
        departmentRepository.deleteById(command.getDepartmentId());
        
        // 审计日志
        auditService.logOperation("删除部门", command.getDepartmentId());
        
        return CommandResult.ok("部门删除成功");
    }
}
```
